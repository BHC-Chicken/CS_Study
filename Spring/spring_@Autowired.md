> @Autowired의 개념을 접하기 이전, DI 개념, SOLID 원칙이 무엇인지 파악하고 접근하자!  

## DI(Dependency Injection)란?  

- DI(Dependency Injection, 의존성 종속)란, 객체 지향 프로그래밍에서 강한 결합도를 가진 객체들 사이의 의존성을 약한 결합도로 만들어주는 설계 원칙이다.

- 스프링 관점에서는 **클래스 간 의존관계를 스프링 컨테이너가 자동으로 연결**해 주는 것을 의미한다. 즉, 객체는 의존성에 대한 관리를 신경쓰지 않고 독립적으로 동작 가능하다.  

### 왜 객체 간 결합도를 낮춰야 하나요?
- 코드의 재사용성, 유지보수성, 테스트 용이성 등이 향상되기 때문이다.

1. 재사용성(Reusability) : 의존성을 외부에서 주입받는 경우, 객체는 독립적으로 동작 가능하다.
    - 객체를 다른 컨텍스트에서 재사용하기 쉬워진다
    - 예를 들어, 데이터베이스 연결을 관리하는 객체를 의존성으로 주입받는 경우, 동일 객체를 다른 데이터베이스에 연결하여 재사용 가능

2. 유지보수성(Maintainability) : 결합도가 낮으면 변경 사항에 대한 영향 범위가 제한된다.
    - 한 객체의 변경이 다른 객체에 영향을 미치지 않기 때문에 코드 수정이 간편해진다
    - 예를 들어, 데이터 소스를 변경해야할 때, 의존성 주입을 통해 데이터 소스를 제공하는 객체만 수정하면 된다

3. 테스트 용이성(Testability) : 객체 간의 결합도가 낮아지면 단위 테스트가 용이해진다.
    - 의존성을 외부에서 주입받기에, 테스트 환경에서 모의 객체(Mocking)를 주입하여 테스트를 수행 가능하다
    - 즉, 의존 객체의 동작을 모의화하여 특정 시나리오를 테스트하는데 도움을 준다

4. 확장성(Scalability) : 새로운 기능을 추가하거나 변경할 때, 객체들 간 결합도가 낮으면 전체 시스템을 다시 구성할 필요 없이 해당 객체만 수정하면 된다.
    - 이는 시스템의 확장성을 높여준다
    - 예를 들어, 새로운 알림 방법을 추가하려면, 알림을 제공하는 객체만 수정하면 된다

5. 관리 용이성(Manageability) : 객체 간 의존성을 외부에서 설정하고 관리하기에, 애플리케이션의 전체 구성과 의존성 관리가 용이해진다.  
    - 의존성 주입 컨테이너를 사용하면 의존성을 중앙 관리 가능하며, 객체 생성과 의존성 설정에 대한 로직을 분리하여 코드의 가독성을 향상시킨다

- 위의 장점들은 객체 지향 프로그래밍의 핵심 원칙인 **SOLID 원칙**을 따르고, 유연하고 테스트 가능한 코드를 작성하기 위해 중요하다.

- 결합도가 낮아지면 코드의 유지보수성과 확장성이 향상되며, 코드의 재사용성과 테스트 용이성도 향상된다.  

### DI(Dependency Injection) 예시
![Factory](img/spring_DI_example.png)  

- SW를 사용하는 클라이언트는 Factory 클래스만을 호출해야하며, 구현체인 ConsoleFactory, UseFactory의 사용을 몰라야한다.  

- 클라이언트마다 전용 Factory 클래스를 생성할 경우, 생산성이 떨어지며, 코드가 노출되기 때문이다.  

- 이를 위해, 스프링은 객체 간 의존성을 주입함으로써, 클라이언트가 사용하는 Factory가 ConsoleFactory인지, UserFactory인지를 감춘다.  

## SOLID 원칙이란?  
- 객체 지향 프로그래밍에서 유지보수 가능하고 확장 가능한 소프트웨어를 설계하기 위한 다섯 가지 원칙의 앞글자를 딴 약어이다.  

1. 단일 책임 원칙(SRP, Single Responsibility Principle)
    - 클래스는 하나의 책임만 가져야 한다. 즉, 클래스는 한 가지 기능 또는 역할을 수행해야 한다
    - 이를 통해 클래스는 한 가지 책임에 집중하며, 변경이 발생할 경우 클래스만 수정하면 된다
    - ex) 주문 관리 시스템에서 주문 정보를 처리하는 클래스 - 주문 생성, 수정, 삭제 관련 책임만 지님 

2. 개방-폐쇄 원칙(OCP, Open-Closed Principle)  
    - 소프트웨어의 엔티티(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야한다  
    - 즉, 기존 코드를 수정하지 않고도 기능을 확장할 수 있어야 한다  
    - 이를 위해 추상화와 다형성을 활용하여 확장 가능한 구조를 만들어야 한다  
    - ex) 도형 그리는 프로그램 - 도형 종류가 늘어날 때마다 기존 로직 변경하지 않고 새로운 도형 추가하게끔 설계  

3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)  
    - 상위 타입 객체는, 하위 타입 객체로 대체 가능해야한다  
    - 즉, 어떤 클래스가 상위 클래스를 상속받을 때, 이 클래스를 사용하는 코드는 상위 클래스의 인스턴스를 언제나 대체 가능한 하위 클래스의 인스턴스로 취급할 수 있어야 한다  
    - ex) 자동차(Car) 인터페이스의 엑셀 메서드 - 무조건 앞으로!!  

4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)  
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존해서는 안된다  
    - 인터페이스는 클라이언트가 필요로 하는 기능에만 집중되어야 하며, 불필요한 메서드를 포함하지 않아야 한다  
    - 즉, 인터페이스는 작고 응집력 있는 단위로 분리되어야 한다  
    - ex) `createOrder()`, `updateOrder()`, `deleteOrder()` 메서드를 포함하는 주문처리 인터페이스 - 주문 조회와 같은 필요없을 수 있는 기능 분리  

5. 의존성 역전 원칙(DIP, Dependency Inversion Principle)  
    - 추상화에 의존해야하며, 구체화에는 의존하면 안된다  
    - 즉, 고수준 모듈은 저수준 모듈에 의존해서는 안되며, 양쪽 모두 추상화에 의존해야한다  
    - 추상화된 인터페이스나 추상 클래스를 통해 의존성을 주입받아야 한다  
    - ex) 데이터베이스에 직접적으로 의존하는 서비스 클래스  

- SOLID 원칙을 통해 코드의 유지보수성, 확장성, 재사용성, 테스트 용이성 등이 향상되며, 더 풍부하고 유연한 객체 지향 소프트웨어 개발이 가능하다.

